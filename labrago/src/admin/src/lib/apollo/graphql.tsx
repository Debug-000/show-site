import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  DateOnly: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Time: { input: any; output: any; }
  TimeOnly: { input: any; output: any; }
};

export type Artist = Node & {
  __typename?: 'Artist';
  age?: Maybe<Scalars['Int']['output']>;
  content?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  createdBy?: Maybe<User>;
  deathDate?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  test?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedBy?: Maybe<User>;
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type ArtistConnection = {
  __typename?: 'ArtistConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ArtistEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ArtistEdge = {
  __typename?: 'ArtistEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Artist>;
};

/** Ordering options for Artist connections */
export type ArtistOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Artists. */
  field: ArtistOrderField;
};

/** Properties by which Artist connections can be ordered. */
export enum ArtistOrderField {
  Age = 'age',
  Content = 'content',
  Id = 'id',
  Name = 'name',
  Test = 'test'
}

/**
 * ArtistWhereInput is used for filtering Artist objects.
 * Input was generated by ent.
 */
export type ArtistWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Int']['input']>;
  ageGT?: InputMaybe<Scalars['Int']['input']>;
  ageGTE?: InputMaybe<Scalars['Int']['input']>;
  ageIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  ageLT?: InputMaybe<Scalars['Int']['input']>;
  ageLTE?: InputMaybe<Scalars['Int']['input']>;
  ageNEQ?: InputMaybe<Scalars['Int']['input']>;
  ageNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<ArtistWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** death_date field predicates */
  deathDate?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateGT?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateGTE?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  deathDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deathDateLT?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateLTE?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  deathDateNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  deathDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ArtistWhereInput>;
  or?: InputMaybe<Array<ArtistWhereInput>>;
  /** test field predicates */
  test?: InputMaybe<Scalars['String']['input']>;
  testContains?: InputMaybe<Scalars['String']['input']>;
  testContainsFold?: InputMaybe<Scalars['String']['input']>;
  testEqualFold?: InputMaybe<Scalars['String']['input']>;
  testGT?: InputMaybe<Scalars['String']['input']>;
  testGTE?: InputMaybe<Scalars['String']['input']>;
  testHasPrefix?: InputMaybe<Scalars['String']['input']>;
  testHasSuffix?: InputMaybe<Scalars['String']['input']>;
  testIn?: InputMaybe<Array<Scalars['String']['input']>>;
  testIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  testLT?: InputMaybe<Scalars['String']['input']>;
  testLTE?: InputMaybe<Scalars['String']['input']>;
  testNEQ?: InputMaybe<Scalars['String']['input']>;
  testNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  testNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ArtistWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateArtistInput is used for create Artist object.
 * Input was generated by ent.
 */
export type CreateArtistInput = {
  age?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  deathDate?: InputMaybe<Scalars['DateTime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  test?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
  user?: InputMaybe<CreateOneUserInput>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type CreateEdgeInput = {
  belongsToCaption?: InputMaybe<Scalars['String']['input']>;
  caption: Scalars['String']['input'];
  private?: InputMaybe<Scalars['Boolean']['input']>;
  relatedEntity: EntityConnectInput;
  relationType: RelationType;
  required?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CreateEntityInput = {
  caption: Scalars['String']['input'];
  displayField: FieldWhereUniqueInput;
  edges?: InputMaybe<CreateManyEdgesInput>;
  fields?: InputMaybe<CreateManyFieldsInput>;
};

export type CreateFieldInput = {
  acceptedValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  caption: Scalars['String']['input'];
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['String']['input']>;
  min?: InputMaybe<Scalars['String']['input']>;
  private?: InputMaybe<Scalars['Boolean']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  type: Scalars['String']['input'];
  unique?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CreateManyArtistInput = {
  connect?: InputMaybe<Array<ArtistWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateArtistInput>>;
};

export type CreateManyEdgesInput = {
  create?: InputMaybe<Array<CreateEdgeInput>>;
};

export type CreateManyFieldsInput = {
  create?: InputMaybe<Array<CreateFieldInput>>;
};

export type CreateManyRelationInput = {
  connect?: InputMaybe<Array<RelationWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateRelationInput>>;
};

export type CreateManyRoleInput = {
  connect?: InputMaybe<Array<RoleWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateRoleInput>>;
};

export type CreateManyUserInput = {
  connect?: InputMaybe<Array<UserWhereUniqueInput>>;
  create?: InputMaybe<Array<CreateUserInput>>;
};

export type CreateOneArtistInput = {
  connect?: InputMaybe<ArtistWhereUniqueInput>;
  create?: InputMaybe<CreateArtistInput>;
};

export type CreateOneRelationInput = {
  connect?: InputMaybe<RelationWhereUniqueInput>;
  create?: InputMaybe<CreateRelationInput>;
};

export type CreateOneRoleInput = {
  connect?: InputMaybe<RoleWhereUniqueInput>;
  create?: InputMaybe<CreateRoleInput>;
};

export type CreateOneUserInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  create?: InputMaybe<CreateUserInput>;
};

/**
 * CreateRelationInput is used for create Relation object.
 * Input was generated by ent.
 */
export type CreateRelationInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  rOneToOne?: InputMaybe<CreateOneUserInput>;
  rOneToOneID?: InputMaybe<Scalars['ID']['input']>;
  rmany?: InputMaybe<CreateManyUserInput>;
  rmanyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  rmanyToMany?: InputMaybe<CreateManyUserInput>;
  rmanyToManyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  rone?: InputMaybe<CreateOneUserInput>;
  roneID?: InputMaybe<Scalars['ID']['input']>;
  tOneToMany?: InputMaybe<CreateOneUserInput>;
  tOneToManyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateRoleInput is used for create Role object.
 * Input was generated by ent.
 */
export type CreateRoleInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  type: RoleRoleType;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  refCreatedBy?: InputMaybe<CreateManyUserInput>;
  refUpdatedBy?: InputMaybe<CreateManyUserInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

export type Edge = {
  __typename?: 'Edge';
  belongsToCaption?: Maybe<Scalars['String']['output']>;
  caption: Scalars['String']['output'];
  name: Scalars['String']['output'];
  private?: Maybe<Scalars['Boolean']['output']>;
  relatedEntity: Entity;
  relationType?: Maybe<RelationType>;
  required?: Maybe<Scalars['Boolean']['output']>;
};

export type EdgeWhereUniqueInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Entity = {
  __typename?: 'Entity';
  caption: Scalars['String']['output'];
  displayField: Field;
  edges?: Maybe<Array<Edge>>;
  fields?: Maybe<Array<Field>>;
  name: Scalars['String']['output'];
  owner: EntityOwner;
  pluralName: Scalars['String']['output'];
};

export type EntityConnectInput = {
  connect: EntityWhereUniqueInput;
};

export enum EntityOwner {
  Admin = 'Admin',
  User = 'User'
}

export type EntityWhereUniqueInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Field = {
  __typename?: 'Field';
  acceptedValues?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  caption: Scalars['String']['output'];
  defaultValue?: Maybe<Scalars['String']['output']>;
  max?: Maybe<Scalars['String']['output']>;
  min?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  private?: Maybe<Scalars['Boolean']['output']>;
  required?: Maybe<Scalars['Boolean']['output']>;
  type: Scalars['String']['output'];
  unique?: Maybe<Scalars['Boolean']['output']>;
};

export type FieldWhereUniqueInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createArtist: Artist;
  createEntity: Entity;
  createManyArtists: Array<Maybe<Artist>>;
  createManyRelations: Array<Maybe<Relation>>;
  createManyRoles: Array<Maybe<Role>>;
  createManyUsers: Array<Maybe<User>>;
  createRelation: Relation;
  createRole: Role;
  createUser: User;
  deleteArtist: Artist;
  deleteEntity: Entity;
  deleteManyArtists: Scalars['Int']['output'];
  deleteManyRelations: Scalars['Int']['output'];
  deleteManyRoles: Scalars['Int']['output'];
  deleteManyUsers: Scalars['Int']['output'];
  deleteRelation: Relation;
  deleteRole: Role;
  deleteUser: User;
  updateArtist: Artist;
  updateEntity: Entity;
  updateManyArtists: Scalars['Int']['output'];
  updateManyRelations: Scalars['Int']['output'];
  updateManyRoles: Scalars['Int']['output'];
  updateManyUsers: Scalars['Int']['output'];
  updateRelation: Relation;
  updateRole: Role;
  updateUser: User;
  upsertArtist: Artist;
  upsertManyArtists: Scalars['Int']['output'];
  upsertManyRelations: Scalars['Int']['output'];
  upsertManyRoles: Scalars['Int']['output'];
  upsertManyUsers: Scalars['Int']['output'];
  upsertRelation: Relation;
  upsertRole: Role;
  upsertUser: User;
};


export type MutationCreateArtistArgs = {
  data: CreateArtistInput;
};


export type MutationCreateEntityArgs = {
  data: CreateEntityInput;
};


export type MutationCreateManyArtistsArgs = {
  data: Array<CreateArtistInput>;
};


export type MutationCreateManyRelationsArgs = {
  data: Array<CreateRelationInput>;
};


export type MutationCreateManyRolesArgs = {
  data: Array<CreateRoleInput>;
};


export type MutationCreateManyUsersArgs = {
  data: Array<CreateUserInput>;
};


export type MutationCreateRelationArgs = {
  data: CreateRelationInput;
};


export type MutationCreateRoleArgs = {
  data: CreateRoleInput;
};


export type MutationCreateUserArgs = {
  data: CreateUserInput;
};


export type MutationDeleteArtistArgs = {
  where: ArtistWhereUniqueInput;
};


export type MutationDeleteEntityArgs = {
  where: EntityWhereUniqueInput;
};


export type MutationDeleteManyArtistsArgs = {
  where: ArtistWhereInput;
};


export type MutationDeleteManyRelationsArgs = {
  where: RelationWhereInput;
};


export type MutationDeleteManyRolesArgs = {
  where: RoleWhereInput;
};


export type MutationDeleteManyUsersArgs = {
  where: UserWhereInput;
};


export type MutationDeleteRelationArgs = {
  where: RelationWhereUniqueInput;
};


export type MutationDeleteRoleArgs = {
  where: RoleWhereUniqueInput;
};


export type MutationDeleteUserArgs = {
  where: UserWhereUniqueInput;
};


export type MutationUpdateArtistArgs = {
  data: UpdateArtistInput;
  where: ArtistWhereUniqueInput;
};


export type MutationUpdateEntityArgs = {
  data: UpdateEntityInput;
  where: EntityWhereUniqueInput;
};


export type MutationUpdateManyArtistsArgs = {
  data: UpdateArtistInput;
  where: ArtistWhereInput;
};


export type MutationUpdateManyRelationsArgs = {
  data: UpdateRelationInput;
  where: RelationWhereInput;
};


export type MutationUpdateManyRolesArgs = {
  data: UpdateRoleInput;
  where: RoleWhereInput;
};


export type MutationUpdateManyUsersArgs = {
  data: UpdateUserInput;
  where: UserWhereInput;
};


export type MutationUpdateRelationArgs = {
  data: UpdateRelationInput;
  where: RelationWhereUniqueInput;
};


export type MutationUpdateRoleArgs = {
  data: UpdateRoleInput;
  where: RoleWhereUniqueInput;
};


export type MutationUpdateUserArgs = {
  data: UpdateUserInput;
  where: UserWhereUniqueInput;
};


export type MutationUpsertArtistArgs = {
  data: CreateArtistInput;
};


export type MutationUpsertManyArtistsArgs = {
  data: Array<CreateArtistInput>;
};


export type MutationUpsertManyRelationsArgs = {
  data: Array<CreateRelationInput>;
};


export type MutationUpsertManyRolesArgs = {
  data: Array<CreateRoleInput>;
};


export type MutationUpsertManyUsersArgs = {
  data: Array<CreateUserInput>;
};


export type MutationUpsertRelationArgs = {
  data: CreateRelationInput;
};


export type MutationUpsertRoleArgs = {
  data: CreateRoleInput;
};


export type MutationUpsertUserArgs = {
  data: CreateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Query = {
  __typename?: 'Query';
  artists?: Maybe<Array<Artist>>;
  artistsConnection: ArtistConnection;
  entities?: Maybe<Array<Entity>>;
  entity?: Maybe<Entity>;
  fields?: Maybe<Array<Field>>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  relations?: Maybe<Array<Relation>>;
  relationsConnection: RelationConnection;
  roles?: Maybe<Array<Role>>;
  rolesConnection: RoleConnection;
  users?: Maybe<Array<User>>;
  usersConnection: UserConnection;
};


export type QueryArtistsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ArtistOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ArtistWhereInput>;
};


export type QueryArtistsConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ArtistOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ArtistWhereInput>;
};


export type QueryEntityArgs = {
  where?: InputMaybe<EntityWhereUniqueInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryRelationsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RelationOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RelationWhereInput>;
};


export type QueryRelationsConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RelationOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RelationWhereInput>;
};


export type QueryRolesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RoleOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryRolesConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RoleOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryUsersArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryUsersConnectionArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};

export type Relation = Node & {
  __typename?: 'Relation';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  createdBy?: Maybe<User>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  rOneToOne?: Maybe<User>;
  rmany?: Maybe<Array<User>>;
  rmanyToMany?: Maybe<Array<User>>;
  rone?: Maybe<User>;
  tOneToMany?: Maybe<User>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type RelationConnection = {
  __typename?: 'RelationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RelationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RelationEdge = {
  __typename?: 'RelationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Relation>;
};

/** Ordering options for Relation connections */
export type RelationOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Relations. */
  field: RelationOrderField;
};

/** Properties by which Relation connections can be ordered. */
export enum RelationOrderField {
  Id = 'id',
  Name = 'name'
}

export enum RelationType {
  Many = 'Many',
  ManyToMany = 'ManyToMany',
  ManyToOne = 'ManyToOne',
  One = 'One',
  OneToMany = 'OneToMany',
  OneToOne = 'OneToOne'
}

/**
 * RelationWhereInput is used for filtering Relation objects.
 * Input was generated by ent.
 */
export type RelationWhereInput = {
  and?: InputMaybe<Array<RelationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** r_one_to_one edge predicates */
  hasROneToOne?: InputMaybe<Scalars['Boolean']['input']>;
  hasROneToOneWith?: InputMaybe<Array<UserWhereInput>>;
  /** rmany edge predicates */
  hasRmany?: InputMaybe<Scalars['Boolean']['input']>;
  /** rmany_to_many edge predicates */
  hasRmanyToMany?: InputMaybe<Scalars['Boolean']['input']>;
  hasRmanyToManyWith?: InputMaybe<Array<UserWhereInput>>;
  hasRmanyWith?: InputMaybe<Array<UserWhereInput>>;
  /** rone edge predicates */
  hasRone?: InputMaybe<Scalars['Boolean']['input']>;
  hasRoneWith?: InputMaybe<Array<UserWhereInput>>;
  /** t_one_to_many edge predicates */
  hasTOneToMany?: InputMaybe<Scalars['Boolean']['input']>;
  hasTOneToManyWith?: InputMaybe<Array<UserWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<RelationWhereInput>;
  or?: InputMaybe<Array<RelationWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RelationWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type Role = Node & {
  __typename?: 'Role';
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdBy?: Maybe<User>;
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  type: RoleRoleType;
  updatedAt?: Maybe<Scalars['Time']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type RoleConnection = {
  __typename?: 'RoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RoleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RoleEdge = {
  __typename?: 'RoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Role>;
};

/** Ordering options for Role connections */
export type RoleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Roles. */
  field: RoleOrderField;
};

/** Properties by which Role connections can be ordered. */
export enum RoleOrderField {
  CreatedAt = 'createdAt',
  Email = 'email',
  Id = 'id',
  Name = 'name',
  Type = 'type',
  UpdatedAt = 'updatedAt'
}

/** RoleRoleType is enum for the field type */
export enum RoleRoleType {
  Admin = 'Admin',
  Api = 'Api'
}

/**
 * RoleWhereInput is used for filtering Role objects.
 * Input was generated by ent.
 */
export type RoleWhereInput = {
  and?: InputMaybe<Array<RoleWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<RoleWhereInput>;
  or?: InputMaybe<Array<RoleWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<RoleRoleType>;
  typeIn?: InputMaybe<Array<RoleRoleType>>;
  typeNEQ?: InputMaybe<RoleRoleType>;
  typeNotIn?: InputMaybe<Array<RoleRoleType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RoleWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateArtistInput is used for update Artist object.
 * Input was generated by ent.
 */
export type UpdateArtistInput = {
  age?: InputMaybe<Scalars['Int']['input']>;
  clearAge?: InputMaybe<Scalars['Boolean']['input']>;
  clearContent?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeathDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  clearTest?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  deathDate?: InputMaybe<Scalars['DateTime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  test?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
  user?: InputMaybe<CreateOneUserInput>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type UpdateEdgeInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  private?: InputMaybe<Scalars['Boolean']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpdateEntityInput = {
  caption?: InputMaybe<Scalars['String']['input']>;
  displayField?: InputMaybe<FieldWhereUniqueInput>;
  edges?: InputMaybe<UpdateManyEdgesInput>;
  fields?: InputMaybe<UpdateManyFieldsInput>;
};

export type UpdateFieldInput = {
  acceptedValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  caption?: InputMaybe<Scalars['String']['input']>;
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  max?: InputMaybe<Scalars['String']['input']>;
  min?: InputMaybe<Scalars['String']['input']>;
  private?: InputMaybe<Scalars['Boolean']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpdateManyEdgesInput = {
  create?: InputMaybe<Array<CreateEdgeInput>>;
  delete?: InputMaybe<Array<EdgeWhereUniqueInput>>;
  update?: InputMaybe<Array<UpdateOneEdgeInput>>;
};

export type UpdateManyFieldsInput = {
  create?: InputMaybe<Array<CreateFieldInput>>;
  delete?: InputMaybe<Array<FieldWhereUniqueInput>>;
  update?: InputMaybe<Array<UpdateOneFieldInput>>;
};

export type UpdateOneEdgeInput = {
  data: UpdateEdgeInput;
  where: EdgeWhereUniqueInput;
};

export type UpdateOneFieldInput = {
  data: UpdateFieldInput;
  where: FieldWhereUniqueInput;
};

/**
 * UpdateRelationInput is used for update Relation object.
 * Input was generated by ent.
 */
export type UpdateRelationInput = {
  addRmanyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addRmanyToManyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCreatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  clearRmany?: InputMaybe<Scalars['Boolean']['input']>;
  clearRmanyToMany?: InputMaybe<Scalars['Boolean']['input']>;
  clearRone?: InputMaybe<Scalars['Boolean']['input']>;
  clearRoneToOne?: InputMaybe<Scalars['Boolean']['input']>;
  clearToneToMany?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<CreateOneUserInput>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  rOneToOne?: InputMaybe<CreateOneUserInput>;
  rOneToOneID?: InputMaybe<Scalars['ID']['input']>;
  removeRmanyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeRmanyToManyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  rmany?: InputMaybe<CreateManyUserInput>;
  rmanyToMany?: InputMaybe<CreateManyUserInput>;
  rone?: InputMaybe<CreateOneUserInput>;
  roneID?: InputMaybe<Scalars['ID']['input']>;
  tOneToMany?: InputMaybe<CreateOneUserInput>;
  tOneToManyID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
  updatedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateRoleInput is used for update Role object.
 * Input was generated by ent.
 */
export type UpdateRoleInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<RoleRoleType>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  createdBy?: InputMaybe<CreateOneUserInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  refCreatedBy?: InputMaybe<CreateManyUserInput>;
  refUpdatedBy?: InputMaybe<CreateManyUserInput>;
  updatedBy?: InputMaybe<CreateOneUserInput>;
};

export type User = Node & {
  __typename?: 'User';
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdBy?: Maybe<User>;
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Time']['output']>;
  updatedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  CreatedAt = 'createdAt',
  Email = 'email',
  Id = 'id',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** updated_by edge predicates */
  hasUpdatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasUpdatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type FieldPropertiesFragment = { __typename?: 'Field', name: string, caption: string, type: string, required?: boolean | null, unique?: boolean | null, defaultValue?: string | null, min?: string | null, max?: string | null, private?: boolean | null, acceptedValues?: Array<string | null> | null };

export type GetEntityFirstLevelSchemaQueryVariables = Exact<{
  name: Scalars['String']['input'];
}>;


export type GetEntityFirstLevelSchemaQuery = { __typename?: 'Query', entity?: { __typename?: 'Entity', name: string, caption: string, displayField: { __typename?: 'Field', name: string, caption: string, type: string, required?: boolean | null, unique?: boolean | null, defaultValue?: string | null, min?: string | null, max?: string | null, private?: boolean | null, acceptedValues?: Array<string | null> | null }, fields?: Array<{ __typename?: 'Field', name: string, caption: string, type: string, required?: boolean | null, unique?: boolean | null, defaultValue?: string | null, min?: string | null, max?: string | null, private?: boolean | null, acceptedValues?: Array<string | null> | null }> | null, edges?: Array<{ __typename?: 'Edge', name: string, caption: string, required?: boolean | null, relationType?: RelationType | null, private?: boolean | null, belongsToCaption?: string | null, relatedEntity: { __typename?: 'Entity', name: string, caption: string } }> | null } | null };

export type GetEntitiesNameCaptionQueryVariables = Exact<{ [key: string]: never; }>;


export type GetEntitiesNameCaptionQuery = { __typename?: 'Query', entities?: Array<{ __typename?: 'Entity', name: string, caption: string }> | null };

export const FieldPropertiesFragmentDoc = gql`
    fragment FieldProperties on Field {
  name
  caption
  type
  required
  unique
  defaultValue
  min
  max
  private
  acceptedValues
}
    `;
export const GetEntityFirstLevelSchemaDocument = gql`
    query GetEntityFirstLevelSchema($name: String!) {
  entity(where: {name: $name}) {
    name
    caption
    displayField {
      ...FieldProperties
    }
    fields {
      ...FieldProperties
    }
    edges {
      name
      caption
      required
      relationType
      private
      relatedEntity {
        name
        caption
      }
      belongsToCaption
    }
  }
}
    ${FieldPropertiesFragmentDoc}`;

/**
 * __useGetEntityFirstLevelSchemaQuery__
 *
 * To run a query within a React component, call `useGetEntityFirstLevelSchemaQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEntityFirstLevelSchemaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEntityFirstLevelSchemaQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useGetEntityFirstLevelSchemaQuery(baseOptions: Apollo.QueryHookOptions<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables> & ({ variables: GetEntityFirstLevelSchemaQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>(GetEntityFirstLevelSchemaDocument, options);
      }
export function useGetEntityFirstLevelSchemaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>(GetEntityFirstLevelSchemaDocument, options);
        }
export function useGetEntityFirstLevelSchemaSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>(GetEntityFirstLevelSchemaDocument, options);
        }
export type GetEntityFirstLevelSchemaQueryHookResult = ReturnType<typeof useGetEntityFirstLevelSchemaQuery>;
export type GetEntityFirstLevelSchemaLazyQueryHookResult = ReturnType<typeof useGetEntityFirstLevelSchemaLazyQuery>;
export type GetEntityFirstLevelSchemaSuspenseQueryHookResult = ReturnType<typeof useGetEntityFirstLevelSchemaSuspenseQuery>;
export type GetEntityFirstLevelSchemaQueryResult = Apollo.QueryResult<GetEntityFirstLevelSchemaQuery, GetEntityFirstLevelSchemaQueryVariables>;
export const GetEntitiesNameCaptionDocument = gql`
    query GetEntitiesNameCaption {
  entities {
    name
    caption
  }
}
    `;

/**
 * __useGetEntitiesNameCaptionQuery__
 *
 * To run a query within a React component, call `useGetEntitiesNameCaptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEntitiesNameCaptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEntitiesNameCaptionQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetEntitiesNameCaptionQuery(baseOptions?: Apollo.QueryHookOptions<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>(GetEntitiesNameCaptionDocument, options);
      }
export function useGetEntitiesNameCaptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>(GetEntitiesNameCaptionDocument, options);
        }
export function useGetEntitiesNameCaptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>(GetEntitiesNameCaptionDocument, options);
        }
export type GetEntitiesNameCaptionQueryHookResult = ReturnType<typeof useGetEntitiesNameCaptionQuery>;
export type GetEntitiesNameCaptionLazyQueryHookResult = ReturnType<typeof useGetEntitiesNameCaptionLazyQuery>;
export type GetEntitiesNameCaptionSuspenseQueryHookResult = ReturnType<typeof useGetEntitiesNameCaptionSuspenseQuery>;
export type GetEntitiesNameCaptionQueryResult = Apollo.QueryResult<GetEntitiesNameCaptionQuery, GetEntitiesNameCaptionQueryVariables>;